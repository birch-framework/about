<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.1 from src/site/markdown/index.md at 2022-03-12

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.1" />
    <title>birch-rest-jaxrs &#x2013; </title>
    <link rel="stylesheet" href="./css/maven-base.css" />
    <link rel="stylesheet" href="./css/maven-theme.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<div id="bannerLeft">birch-rest-jaxrs
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2022-03-12</span>
          &#xA0;| <span id="projectVersion">Version: 1.3.0</span>
      </div>
      <div class="xright"><a href="./" title="birch-rest-jaxrs">birch-rest-jaxrs</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Parent Project</h5>
    <ul>
     <li class="none"><a href="../index.html" title="birch-parent">birch-parent</a></li>
    </ul>
       <h5>Project Documentation</h5>
    <ul>
     <li class="expanded"><a href="project-info.html" title="Project Information">Project Information</a>
      <ul>
       <li class="none"><strong>About</strong></li>
       <li class="none"><a href="licenses.html" title="Licenses">Licenses</a></li>
       <li class="none"><a href="summary.html" title="Summary">Summary</a></li>
       <li class="none"><a href="team.html" title="Team">Team</a></li>
       <li class="none"><a href="scm.html" title="Source Code Management">Source Code Management</a></li>
       <li class="none"><a href="dependencies.html" title="Dependencies">Dependencies</a></li>
      </ul></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<p><a class="externalLink" href="https://javadoc.io/doc/org.birchframework/birch-rest-jaxrs"><img src="https://javadoc.io/badge2/org.birchframework/birch-rest-jaxrs/javadoc.svg" alt="javadoc" /></a></p>
<h1>Birch Framework REST - JAX-RS</h1>
<p>Provides all the necessary dependenices to build JAX-RS-based REST APIs.  Both client and service APIs are supported.  Also provides a utility (Responses) of useful routines to hook into processing of RESTful API verbs and extraction of bodies for API consumers.  Finally, a thin error reporting framework is included with which the Responses utility can be used to streamline RESTful APIs error reporting.</p>
<h1>Usage</h1><section>
<h2><a name="Maven_Dependency"></a>Maven Dependency</h2>
<p>Include birch-rest-jaxrs as a dependency to a microservice&#x2019;s Maven project by adding the following as a dependency in its Maven POM file:</p>

<div>
<div>
<pre class="source">&lt;dependency&gt;
   &lt;groupId&gt;org.birchframework&lt;/groupId&gt;
   &lt;artifactId&gt;birch-rest-jaxrs&lt;/artifactId&gt;
&lt;/dependency&gt;
</pre></div></div>

<h1>Framework</h1></section><section>
<h2><a name="Error_Reporting"></a>Error Reporting</h2>
<p>To create a streamlined error reporting experience that standardizes RESTful APIs error reporting for microserives across the microservices ecosystem, create exactly one enum that implements the ErrorCode interface.  For example:</p>

<div>
<div>
<pre class="source">public enum LogisticsComponent implements Component {
   ORDER,
   PAYMENT,
   SHIPPING
}

@Getter
@RequiredArgsConstructor
public enum LogisticsErrorCode implements ErrorCode&lt;LogisticsErrorCode&gt; {
   L10000(LogisticsComponent.ORDER, &quot;Order not found&quot;),
   L10010(LogisticsComponent.ORDER, &quot;Invlid order ID&quot;),
   L10020(LogisticsComponent.ORDER, &quot;Unable to save order&quot;);

   private final int code = Integer.parseInt(this.name().substring(1));

   private final LogisticsComponent component;
   private final String             description;

   @Override
   public ErrorResponse&lt;LogisticsErrorCode&gt; errorResponse() {
      //...
   }
}
</pre></div></div>

<p>When the microservice starts, the Responses utility class (discussed below) will seek this implementation and use it for translating payloads of APIs that include serialized versions of errors reported by the service.  The following demonstrates the use case:</p>

<div>
<div>
<pre class="source">@JsonInclude(NON_NULL)
@Data
@NoArgsConstructor
public class Order implements Serializable {

   private final UUID   id;
   private final String companyName;
   private final String recipientName;
   private final String recipientAddress1;
   private final String recipientAddress2;
   private final String city;
   private final String stateProvinceCode;
   private final String postalCode;
   private final String countryCode;
   private final String status;
}

@Path(&quot;/orders&quot;)
@Produces(APPLICATION_JSON)
public interface OrderAPI {

   @Path(&quot;/findByID/{id}&quot;)
   @GET
   Response findByID(@PathParam(&quot;id&quot;) final UUID theOrderID);

   @Path(&quot;/save&quot;)
   @POST
   @Consumes(APPLICATION_JSON)
   Response save(final Order theOrder);
}

@Service
@RequiredArgsConstructor
public class OrderAPIImpl implements OrderAPI {
   
   private final OrderRepository orderRepoistory;
   
   public Response findByID(final UUID theOrderID) {
      final Optional&lt;Order&gt; anOrderOptional = orderRepoistory.findById(theOrderID);
      return anOrderOptional.map(order -&gt; Response.ok(order).build())
                            .orElse(Response.status(NOT_FOUND).entity(LogisticsErrorCode.L10000).build());
   }

   public Response save(final Order theOrder) {
      final Optional&lt;Order&gt; anOrderOptional = orderRepoistory.save(theOrder);
      return anOrderOptional.map(order -&gt; Response.ok(order).build())
                            .orElse(Response.status(NOT_MODIFIED).entity(LogisticsErrorCode.L10020).build());
   }
}
</pre></div></div>
</section><section>
<h2><a name="JAX-RS_Resource_Auto-proxy"></a>JAX-RS Resource Auto-proxy</h2>
<p>The annotation <a class="externalLink" href="https://javadoc.io/doc/org.birchframework/birch-rest-jaxrs/latest/org/birchframework/framework/cxf/AutoProxy.html">AutoProxy</a> can be applied to any JAX-RS resource interface in order to auto-create a CXF REST client proxy bean at application boot time, but only if another bean of the same type is not already created in the Spring application context.  Consider the following use case:</p>

<div>
<div>
<pre class="source"># application.yml
api:
  coindesk:
    base-url: https://api.coindesk.com/v1
</pre></div></div>

<div>
<div>
<pre class="source">@Path(&quot;/bpi&quot;)
@Produces(APPLICATION_JSON)
@AutoProxy(baseURI = &quot;${api.coindesk.base-url}&quot;)
public interface CoinDeskResource {

   @Path(&quot;/currentprice.json&quot;)
   @GET
   Response currentPrice();
}

@SpringBootApplication
@EnableREST
public class Application {

   public static void main(final String... theArgs) {
      SpringApplication.run(Application.class, theArgs);
   }
}
</pre></div></div>

<p>The @AutoProxy annotation is provided with a baseURI which is read from the Spring configuration.  At application boot time, the a proxy bean of type CoinDeskResource is created and made available in the Spring Application context to be auto-wired into any other bean that depends on it.  As demonstrated above, with this mechanism no manual @Bean annotated methods are needed within the @SpringBootApplication annotated class to create the JAX-RS proxy for CoinDeskResource.</p>
<p><a class="externalLink" href="https://javadoc.io/doc/org.birchframework/birch-rest-jaxrs/latest/org/birchframework/framework/cxf/EnableREST.html">@EnableREST</a> is a marker annotation that imports several JAX-RS related auto-configurations.  It is a convenient way of auto-configuring CXF to seek JAX-RS annotated resources and Spring configurations, associating them with the <a class="externalLink" href="https://cxf.apache.org/javadoc/latest/org/apache/cxf/bus/spring/SpringBus.html">SpringBus</a>.</p></section><section>
<h2><a name="Span"></a>Span</h2>
<p>The span portion of the birch-rest-jarx provides the means to propogate correlation ID and client locale from JAX-RS clients to servers and beyond.  This is made possible by default via <a class="externalLink" href="https://javadoc.io/doc/org.birchframework/birch-rest-jaxrs/latest/org/birchframework/framework/cxf/EnableREST.html">@EnableREST</a> annotation when placed on a Spring Boot application class.  In the previous examples, the auto-configurations imported by @EnableREST will ensure proper client filters and interceptors are configured for REST endpoint clients.  However, if <a class="externalLink" href="https://javadoc.io/doc/org.birchframework/birch-rest-jaxrs/latest/org/birchframework/framework/cxf/AutoProxy.html">@AutoProxy</a> is not being utilized and JAX-RS client proxies are being manually created, then the client filter must be injected into the proxy as follows:</p>

<div>
<div>
<pre class="source">@SpringBootApplication
@EnableREST
public class Application {

   public static void main(final String... theArgs) {
      SpringApplication.run(Application.class, theArgs);
   }

   @Bean
   OrderAPI orderAPI(@Value(&quot;${logistics.servers.order.base-uri:http://localhost:8080/api}&quot;) final String theBaseURI,
                     final ResourceClientRequestFilter theResourceClientRequestFilter) {
      return JAXRSClientFactory.create(theBaseURI.toString(), OrderAPI.class, List.of(theResourceClientRequestFilter));
   }
}
</pre></div></div>

<p>In the above example, the <a class="externalLink" href="https://cxf.apache.org/javadoc/latest/org/apache/cxf/jaxrs/client/JAXRSClientFactory.html#create-java.lang.String-java.lang.Class-java.util.List-">create</a> method adds the auto-configured client filter to the client proxy&#x2019;s list of providers.  On subsequent method calls to the proxy client, the filter will inject the span information into the request header.  On the server side, a filter picks up the headers transmitted by this client&#x2019;s request, and injects them into a thread-local that is accessible via SpanHeadersContainerBean.</p>
<p>Exactly one <a class="externalLink" href="https://javadoc.io/doc/org.birchframework/birch-common/latest/org/birchframework/dto/Spannable.html">Spannable</a> implementation is required in order to inform the Span farmework which request headers it must propogate throughout the REST API call chain.</p>

<div>
<div>
<pre class="source">public enum LogisticsSpannable implements Spannable&lt;LogisticsSpannable&gt; {
   correlationID,
   locale;
}
</pre></div></div>

<p>If a UI client is transmitting the headers given the same keys as defined by the Spannable implementation, then they too will be injected into the server&#x2019;s thread that is processing the request.</p>
<p>An added benefit of the Span framework is the injection of Spannable implementation&#x2019;s request header keys&#x2019; values into SLF4J&#x2019;s <a class="externalLink" href="https://www.slf4j.org/api/org/slf4j/MDC.html">MDC</a> facility.</p>
<h1>Utilities</h1></section><section>
<h2><a name="Responses"></a>Responses</h2>
<p>The <a class="externalLink" href="https://javadoc.io/doc/org.birchframework/birch-rest-jaxrs/latest/org/birchframework/framework/jaxrs/Responses.html">Responses</a> utility class provides methods to evaluate <a class="externalLink" href="https://javaee.github.io/javaee-spec/javadocs/javax/ws/rs/core/Response.html">Response</a> objects, which are normally returned by JAX-RS-based APIs, in a functional manner.  Using this convention makes software maintenance easier as source code for calling an API and consuming what it returns are co-located.  As an example, consider the following classes:</p>

<div>
<div>
<pre class="source">@SpringBootApplication
public class Application {
   public static void main(final String... theArgs) {
      SpringApplication.run(Application.class, theArgs);
   }

   @Bean          // Here we could have used @AutoProxy instead of this method, but in this example we are explicitly creating the bean
   OrderAPI orderAPI(@Value(&quot;${logistics.servers.order.base-uri:http://localhost:8080/api}&quot;) final String theBaseURI) {
      return JAXRSClientFactory.create(theBaseURI, OrderAPI.class);
   }
}
</pre></div></div>

<p>In the following example, the API which returns a complex object is being called via HTTP GET and the payload is being ingested:</p>

<div>
<div>
<pre class="source">@RequiredArgsConstructor
@Slf4j
public class FulfillmentManager {

   private final OrderAPI orderAPI;

   public String shipOrder(final UUID theOrderID) {
      final var anAtomicOrderStatus = new AtomicReference&lt;Order&gt;();
      Responses.of(this.orderAPI.findByID(theOrderID)).ifOKOrElse(
         Order.class,
         order -&gt; {
            log.debug(&quot;Recipient name: {}&quot;, order.getRecipientName());
            order.setStatus(&quot;SHIPPED&quot;);
            // ... other order object manipulations
            final var aSavedOrder = orderAPI.save(order);
            anAtomicOrder.set(order);
         }, 
         errorCode -&gt; log.error(&quot;Order retrieval failed; {}:{}; error description: {}&quot;, 
                                errorCode.getComponent(), errorCode.getCode(), errorCode.getDescription())
      );
      return anAtomicOrder.get();
   }
}
</pre></div></div></section>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2021&#x2013;2022<a href="https://www.birchframework.org">Birch Framework</a>.
.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>